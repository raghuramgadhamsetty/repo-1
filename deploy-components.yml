# Reusable deploy steps: optionally parse artifact, then run one task per component (skip if not in artifact).
# Use includeParse: true on first call per job (or single call); use includeParse: false on second call (Prod East after Prod West).
# All deploy conditions use ParseArtifact.<repo>_in_artifact (e.g. ParseArtifact.mario_service_in_artifact) so one parse per job is enough.
parameters:
  - name: region
    type: string
  - name: owner
    type: string
  - name: branchName
    type: string
  - name: includeParse
    type: boolean
    default: true

steps:
  - ${{ if eq(parameters.includeParse, true) }}:
    - task: PowerShell@2
      name: ParseArtifact
      displayName: 'Parse artifact â€“ which components to deploy'
      inputs:
        targetType: 'inline'
        script: |
          $infoFile = "$(Pipeline.Workspace)/ci-build-info/all-repos-build-info.txt"
          $inArtifact = @{}
          if (Test-Path $infoFile) {
            foreach ($line in Get-Content $infoFile) {
              $parts = $line -split ' - ', 2
              if ($parts.Count -ge 2) {
                $repo = $parts[0].Trim()
                $version = ($parts[1].Trim())
                # Only deploy repos that have a real build version in the artifact (not NA, not empty)
                $inArtifact[$repo] = ($version -and $version -ne "" -and $version -ine "NA")
              }
            }
          }
          $repoList = @("mario_service", "contra_app", "bomber_man_service", "islander_app_service", "cricket_app", "checkmate_checkers", "baseball_game_service", "pokeman_game", "popeye-service", "main_terraform")
          foreach ($repo in $repoList) {
            $varName = ($repo -replace '-','_') + "_in_artifact"
            $val = if ($inArtifact[$repo]) { "true" } else { "false" }
            Write-Host "##vso[task.setvariable variable=$varName;isOutput=true]$val"
            Write-Host "  $repo -> $varName = $val (deploy only if true)"
          }
  - task: PowerShell@2
    displayName: 'Deploy mario_service_terraform in ${{ parameters.region }}'
    condition: eq(variables['mario_service_terraform_enabled'], 'true')
    env:
      GITHUB_TOKEN: $(GITHUB_TOKEN)
    inputs:
      targetType: 'inline'
      script: |
        $ErrorActionPreference = "Stop"
        $repo = "mario_service"; $workflowFileName = "terraform"
        $owner = "${{ parameters.owner }}"; $branchName = "${{ parameters.branchName }}"; $region = "${{ parameters.region }}"
        $baseUrl = "https://api.github.com"
        $headers = @{ "Authorization" = "token $($env:GITHUB_TOKEN)"; "Accept" = "application/vnd.github.v3+json" }
        $workflows = Invoke-RestMethod -Uri "$baseUrl/repos/$owner/$repo/actions/workflows" -Headers $headers -Method Get
        $tfWf = $workflows.workflows | Where-Object { $_.path -match "$workflowFileName\.(yaml|yml)$" } | Select-Object -First 1
        if (-not $tfWf) { Write-Error "Repo $repo : No workflow matching $workflowFileName.yaml/yml in .github/workflows. Add the file and ensure it has 'workflow_dispatch:' under 'on:'." }
        $body = @{ ref = $branchName } | ConvertTo-Json
        try { Invoke-RestMethod -Uri "$baseUrl/repos/$owner/$repo/actions/workflows/$($tfWf.id)/dispatches" -Headers $headers -Method Post -Body $body -ContentType "application/json" } catch { Write-Error "Dispatch failed for $repo terraform. $_" }
        Write-Host "Triggered mario_service_terraform - ${region}. Waiting..." -ForegroundColor Green
        Start-Sleep -Seconds 5
        $branchEncoded = [System.Uri]::EscapeDataString($branchName)
        $runs = Invoke-RestMethod -Uri "$baseUrl/repos/$owner/$repo/actions/workflows/$($tfWf.id)/runs?branch=$branchEncoded&per_page=5" -Headers $headers -Method Get
        $runId = $runs.workflow_runs[0].id
        do { Start-Sleep -Seconds 10; $run = Invoke-RestMethod -Uri "$baseUrl/repos/$owner/$repo/actions/runs/$runId" -Headers $headers -Method Get; Write-Host "  mario_service_terraform status: $($run.status)" } while ($run.status -ne "completed")
        if ($run.conclusion -ne "success") { Write-Error "Terraform deploy failed for $repo - $($run.conclusion)" }
        Write-Host "mario_service_terraform completed successfully" -ForegroundColor Green
  - task: PowerShell@2
    displayName: 'Deploy component mario_service in ${{ parameters.region }}'
    condition: eq(variables['ParseArtifact.mario_service_in_artifact'], 'true')
    env:
      GITHUB_TOKEN: $(GITHUB_TOKEN)
    inputs:
      targetType: 'inline'
      script: |
        $ErrorActionPreference = "Stop"
        $repo = "mario_service"; $version = ""; $workflowFileName = "deploy"
        $owner = "${{ parameters.owner }}"; $branchName = "${{ parameters.branchName }}"; $region = "${{ parameters.region }}"
        $baseUrl = "https://api.github.com"; $infoFile = "$(Pipeline.Workspace)/ci-build-info/all-repos-build-info.txt"
        foreach ($line in Get-Content $infoFile) { $p = $line -split ' - ', 2; if ($p[0].Trim() -eq $repo -and $p.Count -ge 2) { $version = $p[1].Trim(); break } }
        $headers = @{ "Authorization" = "token $($env:GITHUB_TOKEN)"; "Accept" = "application/vnd.github.v3+json" }
        $workflows = Invoke-RestMethod -Uri "$baseUrl/repos/$owner/$repo/actions/workflows" -Headers $headers -Method Get
        $deployWf = $workflows.workflows | Where-Object { $_.path -match "$workflowFileName\.(yaml|yml)$" } | Select-Object -First 1
        if (-not $deployWf) { Write-Error "Repo $repo : No workflow matching $workflowFileName.yaml/yml in .github/workflows. Add the file and ensure it has 'workflow_dispatch:' under 'on:'." }
        $body = @{ ref = $branchName } | ConvertTo-Json
        try { Invoke-RestMethod -Uri "$baseUrl/repos/$owner/$repo/actions/workflows/$($deployWf.id)/dispatches" -Headers $headers -Method Post -Body $body -ContentType "application/json" } catch { Write-Error "Dispatch failed for $repo. URL: $baseUrl/repos/$owner/$repo/actions/workflows/$($deployWf.id)/dispatches. Ensure workflow has 'workflow_dispatch:' and token has 'workflow' scope. $_" }
        Write-Host "Triggered $repo ($version) - ${region}. Waiting..." -ForegroundColor Green
        Start-Sleep -Seconds 5
        $branchEncoded = [System.Uri]::EscapeDataString($branchName)
        $runs = Invoke-RestMethod -Uri "$baseUrl/repos/$owner/$repo/actions/workflows/$($deployWf.id)/runs?branch=$branchEncoded&per_page=5" -Headers $headers -Method Get
        $runId = $runs.workflow_runs[0].id
        do { Start-Sleep -Seconds 10; $run = Invoke-RestMethod -Uri "$baseUrl/repos/$owner/$repo/actions/runs/$runId" -Headers $headers -Method Get; Write-Host "  $repo status: $($run.status)" } while ($run.status -ne "completed")
        if ($run.conclusion -ne "success") { Write-Error "Deploy failed $repo - $($run.conclusion)" }
        $zipPath = "$(Pipeline.Workspace)/deploy-logs-$repo.zip"
        Invoke-WebRequest -Uri "$baseUrl/repos/$owner/$repo/actions/runs/$runId/logs" -Headers @{ Authorization = "token $($env:GITHUB_TOKEN)" } -OutFile $zipPath -UseBasicParsing
        $extractPath = "$(Pipeline.Workspace)/deploy-logs-$repo"; Expand-Archive -Path $zipPath -DestinationPath $extractPath -Force
        $logFile = Get-ChildItem -Path $extractPath -Recurse -File | Where-Object { $_.Extension -eq ".txt" } | Sort-Object Length -Descending | Select-Object -First 1
        if ($logFile) { Get-Content $logFile.FullName -Tail 3 | ForEach-Object { Write-Host "    $_" } }
        Remove-Item $zipPath -Force -ErrorAction SilentlyContinue; Remove-Item $extractPath -Recurse -Force -ErrorAction SilentlyContinue
  - task: PowerShell@2
    displayName: 'Deploy component contra_app in ${{ parameters.region }}'
    condition: eq(variables['ParseArtifact.contra_app_in_artifact'], 'true')
    env:
      GITHUB_TOKEN: $(GITHUB_TOKEN)
    inputs:
      targetType: 'inline'
      script: |
        $ErrorActionPreference = "Stop"
        $repo = "contra_app"; $version = ""; $workflowFileName = "deploy"
        $owner = "${{ parameters.owner }}"; $branchName = "${{ parameters.branchName }}"; $region = "${{ parameters.region }}"
        $baseUrl = "https://api.github.com"; $infoFile = "$(Pipeline.Workspace)/ci-build-info/all-repos-build-info.txt"
        foreach ($line in Get-Content $infoFile) { $p = $line -split ' - ', 2; if ($p[0].Trim() -eq $repo -and $p.Count -ge 2) { $version = $p[1].Trim(); break } }
        $headers = @{ "Authorization" = "token $($env:GITHUB_TOKEN)"; "Accept" = "application/vnd.github.v3+json" }
        $workflows = Invoke-RestMethod -Uri "$baseUrl/repos/$owner/$repo/actions/workflows" -Headers $headers -Method Get
        $deployWf = $workflows.workflows | Where-Object { $_.path -match "$workflowFileName\.(yaml|yml)$" } | Select-Object -First 1
        if (-not $deployWf) { Write-Error "Repo $repo : No workflow matching $workflowFileName.yaml/yml in .github/workflows. Add the file and ensure it has 'workflow_dispatch:' under 'on:'." }
        $body = @{ ref = $branchName } | ConvertTo-Json
        try { Invoke-RestMethod -Uri "$baseUrl/repos/$owner/$repo/actions/workflows/$($deployWf.id)/dispatches" -Headers $headers -Method Post -Body $body -ContentType "application/json" } catch { Write-Error "Dispatch failed for $repo. $_" }
        Write-Host "Triggered $repo ($version) - ${region}. Waiting..." -ForegroundColor Green
        Start-Sleep -Seconds 5
        $branchEncoded = [System.Uri]::EscapeDataString($branchName)
        $runs = Invoke-RestMethod -Uri "$baseUrl/repos/$owner/$repo/actions/workflows/$($deployWf.id)/runs?branch=$branchEncoded&per_page=5" -Headers $headers -Method Get
        $runId = $runs.workflow_runs[0].id
        do { Start-Sleep -Seconds 10; $run = Invoke-RestMethod -Uri "$baseUrl/repos/$owner/$repo/actions/runs/$runId" -Headers $headers -Method Get; Write-Host "  $repo status: $($run.status)" } while ($run.status -ne "completed")
        if ($run.conclusion -ne "success") { Write-Error "Deploy failed $repo - $($run.conclusion)" }
        $zipPath = "$(Pipeline.Workspace)/deploy-logs-$repo.zip"
        Invoke-WebRequest -Uri "$baseUrl/repos/$owner/$repo/actions/runs/$runId/logs" -Headers @{ Authorization = "token $($env:GITHUB_TOKEN)" } -OutFile $zipPath -UseBasicParsing
        $extractPath = "$(Pipeline.Workspace)/deploy-logs-$repo"; Expand-Archive -Path $zipPath -DestinationPath $extractPath -Force
        $logFile = Get-ChildItem -Path $extractPath -Recurse -File | Where-Object { $_.Extension -eq ".txt" } | Sort-Object Length -Descending | Select-Object -First 1
        if ($logFile) { Get-Content $logFile.FullName -Tail 3 | ForEach-Object { Write-Host "    $_" } }
        Remove-Item $zipPath -Force -ErrorAction SilentlyContinue; Remove-Item $extractPath -Recurse -Force -ErrorAction SilentlyContinue
  - task: PowerShell@2
    displayName: 'Deploy component bomber_man_service in ${{ parameters.region }}'
    condition: eq(variables['ParseArtifact.bomber_man_service_in_artifact'], 'true')
    env:
      GITHUB_TOKEN: $(GITHUB_TOKEN)
    inputs:
      targetType: 'inline'
      script: |
        $ErrorActionPreference = "Stop"
        $repo = "bomber_man_service"; $version = ""; $workflowFileName = "deploy"
        $owner = "${{ parameters.owner }}"; $branchName = "${{ parameters.branchName }}"; $region = "${{ parameters.region }}"
        $baseUrl = "https://api.github.com"; $infoFile = "$(Pipeline.Workspace)/ci-build-info/all-repos-build-info.txt"
        foreach ($line in Get-Content $infoFile) { $p = $line -split ' - ', 2; if ($p[0].Trim() -eq $repo -and $p.Count -ge 2) { $version = $p[1].Trim(); break } }
        $headers = @{ "Authorization" = "token $($env:GITHUB_TOKEN)"; "Accept" = "application/vnd.github.v3+json" }
        $workflows = Invoke-RestMethod -Uri "$baseUrl/repos/$owner/$repo/actions/workflows" -Headers $headers -Method Get
        $deployWf = $workflows.workflows | Where-Object { $_.path -match "$workflowFileName\.(yaml|yml)$" } | Select-Object -First 1
        if (-not $deployWf) { Write-Error "Repo $repo : No workflow matching $workflowFileName.yaml/yml. Add the file and ensure it has 'workflow_dispatch:' under 'on:'." }
        $body = @{ ref = $branchName } | ConvertTo-Json
        try { Invoke-RestMethod -Uri "$baseUrl/repos/$owner/$repo/actions/workflows/$($deployWf.id)/dispatches" -Headers $headers -Method Post -Body $body -ContentType "application/json" } catch { Write-Error "Dispatch failed for $repo. $_" }
        Write-Host "Triggered $repo ($version) - ${region}. Waiting..." -ForegroundColor Green
        Start-Sleep -Seconds 5
        $branchEncoded = [System.Uri]::EscapeDataString($branchName)
        $runs = Invoke-RestMethod -Uri "$baseUrl/repos/$owner/$repo/actions/workflows/$($deployWf.id)/runs?branch=$branchEncoded&per_page=5" -Headers $headers -Method Get
        $runId = $runs.workflow_runs[0].id
        do { Start-Sleep -Seconds 10; $run = Invoke-RestMethod -Uri "$baseUrl/repos/$owner/$repo/actions/runs/$runId" -Headers $headers -Method Get; Write-Host "  $repo status: $($run.status)" } while ($run.status -ne "completed")
        if ($run.conclusion -ne "success") { Write-Error "Deploy failed $repo - $($run.conclusion)" }
        $zipPath = "$(Pipeline.Workspace)/deploy-logs-$repo.zip"
        Invoke-WebRequest -Uri "$baseUrl/repos/$owner/$repo/actions/runs/$runId/logs" -Headers @{ Authorization = "token $($env:GITHUB_TOKEN)" } -OutFile $zipPath -UseBasicParsing
        $extractPath = "$(Pipeline.Workspace)/deploy-logs-$repo"; Expand-Archive -Path $zipPath -DestinationPath $extractPath -Force
        $logFile = Get-ChildItem -Path $extractPath -Recurse -File | Where-Object { $_.Extension -eq ".txt" } | Sort-Object Length -Descending | Select-Object -First 1
        if ($logFile) { Get-Content $logFile.FullName -Tail 3 | ForEach-Object { Write-Host "    $_" } }
        Remove-Item $zipPath -Force -ErrorAction SilentlyContinue; Remove-Item $extractPath -Recurse -Force -ErrorAction SilentlyContinue
  - task: PowerShell@2
    displayName: 'Deploy component islander_app_service in ${{ parameters.region }}'
    condition: eq(variables['ParseArtifact.islander_app_service_in_artifact'], 'true')
    env:
      GITHUB_TOKEN: $(GITHUB_TOKEN)
    inputs:
      targetType: 'inline'
      script: |
        $ErrorActionPreference = "Stop"
        $repo = "islander_app_service"; $version = ""; $workflowFileName = "deploy"
        $owner = "${{ parameters.owner }}"; $branchName = "${{ parameters.branchName }}"; $region = "${{ parameters.region }}"
        $baseUrl = "https://api.github.com"; $infoFile = "$(Pipeline.Workspace)/ci-build-info/all-repos-build-info.txt"
        foreach ($line in Get-Content $infoFile) { $p = $line -split ' - ', 2; if ($p[0].Trim() -eq $repo -and $p.Count -ge 2) { $version = $p[1].Trim(); break } }
        $headers = @{ "Authorization" = "token $($env:GITHUB_TOKEN)"; "Accept" = "application/vnd.github.v3+json" }
        $workflows = Invoke-RestMethod -Uri "$baseUrl/repos/$owner/$repo/actions/workflows" -Headers $headers -Method Get
        $deployWf = $workflows.workflows | Where-Object { $_.path -match "$workflowFileName\.(yaml|yml)$" } | Select-Object -First 1
        if (-not $deployWf) { Write-Error "Repo $repo : No workflow matching $workflowFileName.yaml/yml. Add the file and ensure it has 'workflow_dispatch:' under 'on:'." }
        $body = @{ ref = $branchName } | ConvertTo-Json
        try { Invoke-RestMethod -Uri "$baseUrl/repos/$owner/$repo/actions/workflows/$($deployWf.id)/dispatches" -Headers $headers -Method Post -Body $body -ContentType "application/json" } catch { Write-Error "Dispatch failed for $repo. $_" }
        Write-Host "Triggered $repo ($version) - ${region}. Waiting..." -ForegroundColor Green
        Start-Sleep -Seconds 5
        $branchEncoded = [System.Uri]::EscapeDataString($branchName)
        $runs = Invoke-RestMethod -Uri "$baseUrl/repos/$owner/$repo/actions/workflows/$($deployWf.id)/runs?branch=$branchEncoded&per_page=5" -Headers $headers -Method Get
        $runId = $runs.workflow_runs[0].id
        do { Start-Sleep -Seconds 10; $run = Invoke-RestMethod -Uri "$baseUrl/repos/$owner/$repo/actions/runs/$runId" -Headers $headers -Method Get; Write-Host "  $repo status: $($run.status)" } while ($run.status -ne "completed")
        if ($run.conclusion -ne "success") { Write-Error "Deploy failed $repo - $($run.conclusion)" }
        $zipPath = "$(Pipeline.Workspace)/deploy-logs-$repo.zip"
        Invoke-WebRequest -Uri "$baseUrl/repos/$owner/$repo/actions/runs/$runId/logs" -Headers @{ Authorization = "token $($env:GITHUB_TOKEN)" } -OutFile $zipPath -UseBasicParsing
        $extractPath = "$(Pipeline.Workspace)/deploy-logs-$repo"; Expand-Archive -Path $zipPath -DestinationPath $extractPath -Force
        $logFile = Get-ChildItem -Path $extractPath -Recurse -File | Where-Object { $_.Extension -eq ".txt" } | Sort-Object Length -Descending | Select-Object -First 1
        if ($logFile) { Get-Content $logFile.FullName -Tail 3 | ForEach-Object { Write-Host "    $_" } }
        Remove-Item $zipPath -Force -ErrorAction SilentlyContinue; Remove-Item $extractPath -Recurse -Force -ErrorAction SilentlyContinue
  - task: PowerShell@2
    displayName: 'Deploy component cricket_app in ${{ parameters.region }}'
    condition: eq(variables['ParseArtifact.cricket_app_in_artifact'], 'true')
    env:
      GITHUB_TOKEN: $(GITHUB_TOKEN)
    inputs:
      targetType: 'inline'
      script: |
        $ErrorActionPreference = "Stop"
        $repo = "cricket_app"; $version = ""; $workflowFileName = "deploy"
        $owner = "${{ parameters.owner }}"; $branchName = "${{ parameters.branchName }}"; $region = "${{ parameters.region }}"
        $baseUrl = "https://api.github.com"; $infoFile = "$(Pipeline.Workspace)/ci-build-info/all-repos-build-info.txt"
        foreach ($line in Get-Content $infoFile) { $p = $line -split ' - ', 2; if ($p[0].Trim() -eq $repo -and $p.Count -ge 2) { $version = $p[1].Trim(); break } }
        $headers = @{ "Authorization" = "token $($env:GITHUB_TOKEN)"; "Accept" = "application/vnd.github.v3+json" }
        $workflows = Invoke-RestMethod -Uri "$baseUrl/repos/$owner/$repo/actions/workflows" -Headers $headers -Method Get
        $deployWf = $workflows.workflows | Where-Object { $_.path -match "$workflowFileName\.(yaml|yml)$" } | Select-Object -First 1
        if (-not $deployWf) { Write-Error "Repo $repo : No workflow matching $workflowFileName.yaml/yml. Add the file and ensure it has 'workflow_dispatch:' under 'on:'." }
        $body = @{ ref = $branchName } | ConvertTo-Json
        try { Invoke-RestMethod -Uri "$baseUrl/repos/$owner/$repo/actions/workflows/$($deployWf.id)/dispatches" -Headers $headers -Method Post -Body $body -ContentType "application/json" } catch { Write-Error "Dispatch failed for $repo. $_" }
        Write-Host "Triggered $repo ($version) - ${region}. Waiting..." -ForegroundColor Green
        Start-Sleep -Seconds 5
        $branchEncoded = [System.Uri]::EscapeDataString($branchName)
        $runs = Invoke-RestMethod -Uri "$baseUrl/repos/$owner/$repo/actions/workflows/$($deployWf.id)/runs?branch=$branchEncoded&per_page=5" -Headers $headers -Method Get
        $runId = $runs.workflow_runs[0].id
        do { Start-Sleep -Seconds 10; $run = Invoke-RestMethod -Uri "$baseUrl/repos/$owner/$repo/actions/runs/$runId" -Headers $headers -Method Get; Write-Host "  $repo status: $($run.status)" } while ($run.status -ne "completed")
        if ($run.conclusion -ne "success") { Write-Error "Deploy failed $repo - $($run.conclusion)" }
        $zipPath = "$(Pipeline.Workspace)/deploy-logs-$repo.zip"
        Invoke-WebRequest -Uri "$baseUrl/repos/$owner/$repo/actions/runs/$runId/logs" -Headers @{ Authorization = "token $($env:GITHUB_TOKEN)" } -OutFile $zipPath -UseBasicParsing
        $extractPath = "$(Pipeline.Workspace)/deploy-logs-$repo"; Expand-Archive -Path $zipPath -DestinationPath $extractPath -Force
        $logFile = Get-ChildItem -Path $extractPath -Recurse -File | Where-Object { $_.Extension -eq ".txt" } | Sort-Object Length -Descending | Select-Object -First 1
        if ($logFile) { Get-Content $logFile.FullName -Tail 3 | ForEach-Object { Write-Host "    $_" } }
        Remove-Item $zipPath -Force -ErrorAction SilentlyContinue; Remove-Item $extractPath -Recurse -Force -ErrorAction SilentlyContinue
  - task: PowerShell@2
    displayName: 'Deploy component checkmate_checkers in ${{ parameters.region }}'
    condition: eq(variables['ParseArtifact.checkmate_checkers_in_artifact'], 'true')
    env:
      GITHUB_TOKEN: $(GITHUB_TOKEN)
    inputs:
      targetType: 'inline'
      script: |
        $ErrorActionPreference = "Stop"
        $repo = "checkmate_checkers"; $version = ""; $workflowFileName = "deploy"
        $owner = "${{ parameters.owner }}"; $branchName = "${{ parameters.branchName }}"; $region = "${{ parameters.region }}"
        $baseUrl = "https://api.github.com"; $infoFile = "$(Pipeline.Workspace)/ci-build-info/all-repos-build-info.txt"
        foreach ($line in Get-Content $infoFile) { $p = $line -split ' - ', 2; if ($p[0].Trim() -eq $repo -and $p.Count -ge 2) { $version = $p[1].Trim(); break } }
        $headers = @{ "Authorization" = "token $($env:GITHUB_TOKEN)"; "Accept" = "application/vnd.github.v3+json" }
        $workflows = Invoke-RestMethod -Uri "$baseUrl/repos/$owner/$repo/actions/workflows" -Headers $headers -Method Get
        $deployWf = $workflows.workflows | Where-Object { $_.path -match "$workflowFileName\.(yaml|yml)$" } | Select-Object -First 1
        if (-not $deployWf) { Write-Error "Repo $repo : No workflow matching $workflowFileName.yaml/yml. Add the file and ensure it has 'workflow_dispatch:' under 'on:'." }
        $body = @{ ref = $branchName } | ConvertTo-Json
        try { Invoke-RestMethod -Uri "$baseUrl/repos/$owner/$repo/actions/workflows/$($deployWf.id)/dispatches" -Headers $headers -Method Post -Body $body -ContentType "application/json" } catch { Write-Error "Dispatch failed for $repo. $_" }
        Write-Host "Triggered $repo ($version) - ${region}. Waiting..." -ForegroundColor Green
        Start-Sleep -Seconds 5
        $branchEncoded = [System.Uri]::EscapeDataString($branchName)
        $runs = Invoke-RestMethod -Uri "$baseUrl/repos/$owner/$repo/actions/workflows/$($deployWf.id)/runs?branch=$branchEncoded&per_page=5" -Headers $headers -Method Get
        $runId = $runs.workflow_runs[0].id
        do { Start-Sleep -Seconds 10; $run = Invoke-RestMethod -Uri "$baseUrl/repos/$owner/$repo/actions/runs/$runId" -Headers $headers -Method Get; Write-Host "  $repo status: $($run.status)" } while ($run.status -ne "completed")
        if ($run.conclusion -ne "success") { Write-Error "Deploy failed $repo - $($run.conclusion)" }
        $zipPath = "$(Pipeline.Workspace)/deploy-logs-$repo.zip"
        Invoke-WebRequest -Uri "$baseUrl/repos/$owner/$repo/actions/runs/$runId/logs" -Headers @{ Authorization = "token $($env:GITHUB_TOKEN)" } -OutFile $zipPath -UseBasicParsing
        $extractPath = "$(Pipeline.Workspace)/deploy-logs-$repo"; Expand-Archive -Path $zipPath -DestinationPath $extractPath -Force
        $logFile = Get-ChildItem -Path $extractPath -Recurse -File | Where-Object { $_.Extension -eq ".txt" } | Sort-Object Length -Descending | Select-Object -First 1
        if ($logFile) { Get-Content $logFile.FullName -Tail 3 | ForEach-Object { Write-Host "    $_" } }
        Remove-Item $zipPath -Force -ErrorAction SilentlyContinue; Remove-Item $extractPath -Recurse -Force -ErrorAction SilentlyContinue
  - task: PowerShell@2
    displayName: 'Deploy component baseball_game_service in ${{ parameters.region }}'
    condition: eq(variables['ParseArtifact.baseball_game_service_in_artifact'], 'true')
    env:
      GITHUB_TOKEN: $(GITHUB_TOKEN)
    inputs:
      targetType: 'inline'
      script: |
        $ErrorActionPreference = "Stop"
        $repo = "baseball_game_service"; $version = ""; $workflowFileName = "deploy"
        $owner = "${{ parameters.owner }}"; $branchName = "${{ parameters.branchName }}"; $region = "${{ parameters.region }}"
        $baseUrl = "https://api.github.com"; $infoFile = "$(Pipeline.Workspace)/ci-build-info/all-repos-build-info.txt"
        foreach ($line in Get-Content $infoFile) { $p = $line -split ' - ', 2; if ($p[0].Trim() -eq $repo -and $p.Count -ge 2) { $version = $p[1].Trim(); break } }
        $headers = @{ "Authorization" = "token $($env:GITHUB_TOKEN)"; "Accept" = "application/vnd.github.v3+json" }
        $workflows = Invoke-RestMethod -Uri "$baseUrl/repos/$owner/$repo/actions/workflows" -Headers $headers -Method Get
        $deployWf = $workflows.workflows | Where-Object { $_.path -match "$workflowFileName\.(yaml|yml)$" } | Select-Object -First 1
        if (-not $deployWf) { Write-Error "Repo $repo : No workflow matching $workflowFileName.yaml/yml. Add the file and ensure it has 'workflow_dispatch:' under 'on:'." }
        $body = @{ ref = $branchName } | ConvertTo-Json
        try { Invoke-RestMethod -Uri "$baseUrl/repos/$owner/$repo/actions/workflows/$($deployWf.id)/dispatches" -Headers $headers -Method Post -Body $body -ContentType "application/json" } catch { Write-Error "Dispatch failed for $repo. $_" }
        Write-Host "Triggered $repo ($version) - ${region}. Waiting..." -ForegroundColor Green
        Start-Sleep -Seconds 5
        $branchEncoded = [System.Uri]::EscapeDataString($branchName)
        $runs = Invoke-RestMethod -Uri "$baseUrl/repos/$owner/$repo/actions/workflows/$($deployWf.id)/runs?branch=$branchEncoded&per_page=5" -Headers $headers -Method Get
        $runId = $runs.workflow_runs[0].id
        do { Start-Sleep -Seconds 10; $run = Invoke-RestMethod -Uri "$baseUrl/repos/$owner/$repo/actions/runs/$runId" -Headers $headers -Method Get; Write-Host "  $repo status: $($run.status)" } while ($run.status -ne "completed")
        if ($run.conclusion -ne "success") { Write-Error "Deploy failed $repo - $($run.conclusion)" }
        $zipPath = "$(Pipeline.Workspace)/deploy-logs-$repo.zip"
        Invoke-WebRequest -Uri "$baseUrl/repos/$owner/$repo/actions/runs/$runId/logs" -Headers @{ Authorization = "token $($env:GITHUB_TOKEN)" } -OutFile $zipPath -UseBasicParsing
        $extractPath = "$(Pipeline.Workspace)/deploy-logs-$repo"; Expand-Archive -Path $zipPath -DestinationPath $extractPath -Force
        $logFile = Get-ChildItem -Path $extractPath -Recurse -File | Where-Object { $_.Extension -eq ".txt" } | Sort-Object Length -Descending | Select-Object -First 1
        if ($logFile) { Get-Content $logFile.FullName -Tail 3 | ForEach-Object { Write-Host "    $_" } }
        Remove-Item $zipPath -Force -ErrorAction SilentlyContinue; Remove-Item $extractPath -Recurse -Force -ErrorAction SilentlyContinue
  - task: PowerShell@2
    displayName: 'Deploy component pokeman_game in ${{ parameters.region }}'
    condition: eq(variables['ParseArtifact.pokeman_game_in_artifact'], 'true')
    env:
      GITHUB_TOKEN: $(GITHUB_TOKEN)
    inputs:
      targetType: 'inline'
      script: |
        $ErrorActionPreference = "Stop"
        $repo = "pokeman_game"; $version = ""; $workflowFileName = "deploy"
        $owner = "${{ parameters.owner }}"; $branchName = "${{ parameters.branchName }}"; $region = "${{ parameters.region }}"
        $baseUrl = "https://api.github.com"; $infoFile = "$(Pipeline.Workspace)/ci-build-info/all-repos-build-info.txt"
        foreach ($line in Get-Content $infoFile) { $p = $line -split ' - ', 2; if ($p[0].Trim() -eq $repo -and $p.Count -ge 2) { $version = $p[1].Trim(); break } }
        $headers = @{ "Authorization" = "token $($env:GITHUB_TOKEN)"; "Accept" = "application/vnd.github.v3+json" }
        $workflows = Invoke-RestMethod -Uri "$baseUrl/repos/$owner/$repo/actions/workflows" -Headers $headers -Method Get
        $deployWf = $workflows.workflows | Where-Object { $_.path -match "$workflowFileName\.(yaml|yml)$" } | Select-Object -First 1
        if (-not $deployWf) { Write-Error "Repo $repo : No workflow matching $workflowFileName.yaml/yml. Add the file and ensure it has 'workflow_dispatch:' under 'on:'." }
        $body = @{ ref = $branchName } | ConvertTo-Json
        try { Invoke-RestMethod -Uri "$baseUrl/repos/$owner/$repo/actions/workflows/$($deployWf.id)/dispatches" -Headers $headers -Method Post -Body $body -ContentType "application/json" } catch { Write-Error "Dispatch failed for $repo. $_" }
        Write-Host "Triggered $repo ($version) - ${region}. Waiting..." -ForegroundColor Green
        Start-Sleep -Seconds 5
        $branchEncoded = [System.Uri]::EscapeDataString($branchName)
        $runs = Invoke-RestMethod -Uri "$baseUrl/repos/$owner/$repo/actions/workflows/$($deployWf.id)/runs?branch=$branchEncoded&per_page=5" -Headers $headers -Method Get
        $runId = $runs.workflow_runs[0].id
        do { Start-Sleep -Seconds 10; $run = Invoke-RestMethod -Uri "$baseUrl/repos/$owner/$repo/actions/runs/$runId" -Headers $headers -Method Get; Write-Host "  $repo status: $($run.status)" } while ($run.status -ne "completed")
        if ($run.conclusion -ne "success") { Write-Error "Deploy failed $repo - $($run.conclusion)" }
        $zipPath = "$(Pipeline.Workspace)/deploy-logs-$repo.zip"
        Invoke-WebRequest -Uri "$baseUrl/repos/$owner/$repo/actions/runs/$runId/logs" -Headers @{ Authorization = "token $($env:GITHUB_TOKEN)" } -OutFile $zipPath -UseBasicParsing
        $extractPath = "$(Pipeline.Workspace)/deploy-logs-$repo"; Expand-Archive -Path $zipPath -DestinationPath $extractPath -Force
        $logFile = Get-ChildItem -Path $extractPath -Recurse -File | Where-Object { $_.Extension -eq ".txt" } | Sort-Object Length -Descending | Select-Object -First 1
        if ($logFile) { Get-Content $logFile.FullName -Tail 3 | ForEach-Object { Write-Host "    $_" } }
        Remove-Item $zipPath -Force -ErrorAction SilentlyContinue; Remove-Item $extractPath -Recurse -Force -ErrorAction SilentlyContinue
  - task: PowerShell@2
    displayName: 'Deploy component popeye-service in ${{ parameters.region }}'
    condition: eq(variables['ParseArtifact.popeye_service_in_artifact'], 'true')
    env:
      GITHUB_TOKEN: $(GITHUB_TOKEN)
    inputs:
      targetType: 'inline'
      script: |
        $ErrorActionPreference = "Stop"
        $repo = "popeye-service"; $version = ""; $workflowFileName = "deploy"
        $owner = "${{ parameters.owner }}"; $branchName = "${{ parameters.branchName }}"; $region = "${{ parameters.region }}"
        $baseUrl = "https://api.github.com"; $infoFile = "$(Pipeline.Workspace)/ci-build-info/all-repos-build-info.txt"
        foreach ($line in Get-Content $infoFile) { $p = $line -split ' - ', 2; if ($p[0].Trim() -eq $repo -and $p.Count -ge 2) { $version = $p[1].Trim(); break } }
        $headers = @{ "Authorization" = "token $($env:GITHUB_TOKEN)"; "Accept" = "application/vnd.github.v3+json" }
        $workflows = Invoke-RestMethod -Uri "$baseUrl/repos/$owner/$repo/actions/workflows" -Headers $headers -Method Get
        $deployWf = $workflows.workflows | Where-Object { $_.path -match "$workflowFileName\.(yaml|yml)$" } | Select-Object -First 1
        if (-not $deployWf) { Write-Error "Repo $repo : No workflow matching $workflowFileName.yaml/yml. Add the file and ensure it has 'workflow_dispatch:' under 'on:'." }
        $body = @{ ref = $branchName } | ConvertTo-Json
        try { Invoke-RestMethod -Uri "$baseUrl/repos/$owner/$repo/actions/workflows/$($deployWf.id)/dispatches" -Headers $headers -Method Post -Body $body -ContentType "application/json" } catch { Write-Error "Dispatch failed for $repo. $_" }
        Write-Host "Triggered $repo ($version) - ${region}. Waiting..." -ForegroundColor Green
        Start-Sleep -Seconds 5
        $branchEncoded = [System.Uri]::EscapeDataString($branchName)
        $runs = Invoke-RestMethod -Uri "$baseUrl/repos/$owner/$repo/actions/workflows/$($deployWf.id)/runs?branch=$branchEncoded&per_page=5" -Headers $headers -Method Get
        $runId = $runs.workflow_runs[0].id
        do { Start-Sleep -Seconds 10; $run = Invoke-RestMethod -Uri "$baseUrl/repos/$owner/$repo/actions/runs/$runId" -Headers $headers -Method Get; Write-Host "  $repo status: $($run.status)" } while ($run.status -ne "completed")
        if ($run.conclusion -ne "success") { Write-Error "Deploy failed $repo - $($run.conclusion)" }
        $zipPath = "$(Pipeline.Workspace)/deploy-logs-$repo.zip"
        Invoke-WebRequest -Uri "$baseUrl/repos/$owner/$repo/actions/runs/$runId/logs" -Headers @{ Authorization = "token $($env:GITHUB_TOKEN)" } -OutFile $zipPath -UseBasicParsing
        $extractPath = "$(Pipeline.Workspace)/deploy-logs-$repo"; Expand-Archive -Path $zipPath -DestinationPath $extractPath -Force
        $logFile = Get-ChildItem -Path $extractPath -Recurse -File | Where-Object { $_.Extension -eq ".txt" } | Sort-Object Length -Descending | Select-Object -First 1
        if ($logFile) { Get-Content $logFile.FullName -Tail 3 | ForEach-Object { Write-Host "    $_" } }
        Remove-Item $zipPath -Force -ErrorAction SilentlyContinue; Remove-Item $extractPath -Recurse -Force -ErrorAction SilentlyContinue
  - task: PowerShell@2
    displayName: 'Deploy component main_terraform in ${{ parameters.region }}'
    condition: eq(variables['ParseArtifact.main_terraform_in_artifact'], 'true')
    env:
      GITHUB_TOKEN: $(GITHUB_TOKEN)
    inputs:
      targetType: 'inline'
      script: |
        $ErrorActionPreference = "Stop"
        $repo = "main_terraform"; $version = ""; $workflowFileName = "deploy"
        $owner = "${{ parameters.owner }}"; $branchName = "${{ parameters.branchName }}"; $region = "${{ parameters.region }}"
        $baseUrl = "https://api.github.com"; $infoFile = "$(Pipeline.Workspace)/ci-build-info/all-repos-build-info.txt"
        foreach ($line in Get-Content $infoFile) { $p = $line -split ' - ', 2; if ($p[0].Trim() -eq $repo -and $p.Count -ge 2) { $version = $p[1].Trim(); break } }
        $headers = @{ "Authorization" = "token $($env:GITHUB_TOKEN)"; "Accept" = "application/vnd.github.v3+json" }
        $workflows = Invoke-RestMethod -Uri "$baseUrl/repos/$owner/$repo/actions/workflows" -Headers $headers -Method Get
        $deployWf = $workflows.workflows | Where-Object { $_.path -match "$workflowFileName\.(yaml|yml)$" } | Select-Object -First 1
        if (-not $deployWf) { Write-Error "Repo $repo : No workflow matching $workflowFileName.yaml/yml. Add the file and ensure it has 'workflow_dispatch:' under 'on:'." }
        $body = @{ ref = $branchName } | ConvertTo-Json
        try { Invoke-RestMethod -Uri "$baseUrl/repos/$owner/$repo/actions/workflows/$($deployWf.id)/dispatches" -Headers $headers -Method Post -Body $body -ContentType "application/json" } catch { Write-Error "Dispatch failed for $repo. $_" }
        Write-Host "Triggered $repo ($version) - ${region}. Waiting..." -ForegroundColor Green
        Start-Sleep -Seconds 5
        $branchEncoded = [System.Uri]::EscapeDataString($branchName)
        $runs = Invoke-RestMethod -Uri "$baseUrl/repos/$owner/$repo/actions/workflows/$($deployWf.id)/runs?branch=$branchEncoded&per_page=5" -Headers $headers -Method Get
        $runId = $runs.workflow_runs[0].id
        do { Start-Sleep -Seconds 10; $run = Invoke-RestMethod -Uri "$baseUrl/repos/$owner/$repo/actions/runs/$runId" -Headers $headers -Method Get; Write-Host "  $repo status: $($run.status)" } while ($run.status -ne "completed")
        if ($run.conclusion -ne "success") { Write-Error "Deploy failed $repo - $($run.conclusion)" }
        $zipPath = "$(Pipeline.Workspace)/deploy-logs-$repo.zip"
        Invoke-WebRequest -Uri "$baseUrl/repos/$owner/$repo/actions/runs/$runId/logs" -Headers @{ Authorization = "token $($env:GITHUB_TOKEN)" } -OutFile $zipPath -UseBasicParsing
        $extractPath = "$(Pipeline.Workspace)/deploy-logs-$repo"; Expand-Archive -Path $zipPath -DestinationPath $extractPath -Force
        $logFile = Get-ChildItem -Path $extractPath -Recurse -File | Where-Object { $_.Extension -eq ".txt" } | Sort-Object Length -Descending | Select-Object -First 1
        if ($logFile) { Get-Content $logFile.FullName -Tail 3 | ForEach-Object { Write-Host "    $_" } }
        Remove-Item $zipPath -Force -ErrorAction SilentlyContinue; Remove-Item $extractPath -Recurse -Force -ErrorAction SilentlyContinue
