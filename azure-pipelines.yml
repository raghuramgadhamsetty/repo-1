# Pipeline: Create a branch in all 10 GitHub repos (mario_service, contra_app, ...)
# Pipeline inputs: variableGroupName, branchName, prevReleaseBranch, githubOwner, prodActiveRegion.
# Component deploy enabled and BuildVersion override come from the variable group (e.g. RELEASE_03_20).

name: ReleasePipeline-$(Build.BuildId)-$(Date:yyyyMMddHHmmss)
appendCommitMessageToRunName: false

trigger: none

parameters:
  - name: variableGroupName
    displayName: 'Variable group name'
    type: string
  - name: branchName
    displayName: 'Branch name to create'
    type: string
  - name: prevReleaseBranch
    displayName: 'Previous release branch (create new branch from this)'
    type: string
    default: main
  - name: githubOwner
    displayName: 'GitHub owner/username'
    type: string
    default: 'raghuramgadhamsetty'
  - name: prodActiveRegion
    displayName: 'Prod active region'
    type: string
    default: 'EAST-ACTIVE-WEST-PASSIVE'
    values:
      - 'EAST-ACTIVE-WEST-PASSIVE'
      - 'WEST-ACTIVE-EAST-PASSIVE'

variables:
  - group: ${{ parameters.variableGroupName }}
  - name: branchName
    value: ${{ parameters.branchName }}
  - name: prevReleaseBranch
    value: ${{ parameters.prevReleaseBranch }}
  - name: githubOwner
    value: ${{ parameters.githubOwner }}
  - name: prodActiveRegion
    value: ${{ parameters.prodActiveRegion }}
  - name: repoList
    value: 'mario_service,contra_app,bomber_man_service,islander_app_service,cricket_app,checkmate_checkers,baseball_game_service,pokeman_game,popeye-service,main_terraform'

stages:
  - stage: Validate
    displayName: 'Validate inputs'
    jobs:
      - job: ValidateInputs
        displayName: 'Check parameters'
        pool:
          name: 'Default'
        steps:
          - script: |
              echo "Branch name: $(branchName)"
              echo "Previous release branch: $(prevReleaseBranch)"
              echo "GitHub owner: $(githubOwner)"
              echo "Components enabled: mario_service=$(mario_service_deploy_enabled) contra_app=$(contra_app_deploy_enabled) bomber_man_service=$(bomber_man_service_deploy_enabled) islander_app_service=$(islander_app_service_deploy_enabled) cricket_app=$(cricket_app_deploy_enabled) checkmate_checkers=$(checkmate_checkers_deploy_enabled) baseball_game_service=$(baseball_game_service_deploy_enabled) pokeman_game=$(pokeman_game_deploy_enabled) popeye-service=$(popeye_service_deploy_enabled) main_terraform=$(main_terraform_deploy_enabled)"'
            displayName: 'Show parameters'

  - stage: CreateBranch
    displayName: 'Create branch in all repos'
    dependsOn: Validate
    jobs:
      - job: CreateBranchInAllRepos
        displayName: 'Create branch across all 10 components'
        pool:
          name: 'Default'
        steps:
          - task: PowerShell@2
            displayName: 'Create branch in all 10 repos'
            env:
              GITHUB_TOKEN: $(GITHUB_TOKEN)
            inputs:
              targetType: 'inline'
              script: |
                $ErrorActionPreference = "Stop"
                $branchName = "$(branchName)"
                $prevReleaseBranch = "$(prevReleaseBranch)"
                $owner = "$(githubOwner)"
                # Stage 2 only: create branch in all 10 components regardless of enabled/disabled
                $repos = @("mario_service", "contra_app", "bomber_man_service", "islander_app_service", "cricket_app", "checkmate_checkers", "baseball_game_service", "pokeman_game", "popeye-service", "main_terraform")
                $baseUrl = "https://api.github.com"

                if (-not $env:GITHUB_TOKEN) {
                  Write-Error "GITHUB_TOKEN is not set. Add a secret pipeline variable named GITHUB_TOKEN with your GitHub PAT (scope: repo)."
                }
                if (-not $branchName) {
                  Write-Error "Branch name is required. Run the pipeline with the branchName parameter."
                }
                if (-not $prevReleaseBranch) {
                  Write-Error "Previous release branch is required. Run the pipeline with the prevReleaseBranch parameter."
                }

                $headers = @{
                  "Authorization" = "token $($env:GITHUB_TOKEN)"
                  "Accept"        = "application/vnd.github.v3+json"
                }

                foreach ($repo in $repos) {
                  try {
                    # Get previous release branch SHA - fail if branch does not exist
                    $ref = "heads/" + [System.Uri]::EscapeDataString($prevReleaseBranch)
                    $refInfo = Invoke-RestMethod -Uri "$baseUrl/repos/$owner/$repo/git/ref/$ref" -Headers $headers -Method Get
                    $sha = $refInfo.object.sha
                  } catch {
                    $statusCode = [int]$_.Exception.Response.StatusCode
                    if ($statusCode -eq 401) {
                      Write-Error "GitHub returned 401 Unauthorized for $repo. Check: (1) GITHUB_TOKEN is set in Pipeline variables (as a secret). (2) Token is a valid GitHub PAT with 'repo' scope. (3) Token has access to owner '$owner' and repo '$repo'."
                    } elseif ($statusCode -eq 404) {
                      Write-Error "Previous branch '$prevReleaseBranch' does not exist in $repo. Pipeline failed."
                    } else {
                      throw $_
                    }
                  }

                  try {
                    # Create new branch from previous release
                    $body = @{ ref = "refs/heads/$branchName"; sha = $sha } | ConvertTo-Json
                    Invoke-RestMethod -Uri "$baseUrl/repos/$owner/$repo/git/refs" -Headers $headers -Method Post -Body $body -ContentType "application/json"
                    Write-Host "Created branch '$branchName' in $repo" -ForegroundColor Green
                  } catch {
                    if ($_.Exception.Response.StatusCode -eq 422) {
                      Write-Host "Branch '$branchName' already exists in $repo (skipped)" -ForegroundColor Yellow
                    } else {
                      Write-Host "Failed for $repo : $_" -ForegroundColor Red
                    }
                  }
                }
                Write-Host "`nDone. Branch '$branchName' is now in all 10 repos." -ForegroundColor Cyan

  # Stage 3: Requires approval before generating artifact.
  # Create environment 'ci-build-approval' in DevOps (Pipelines > Environments) and add Approvals.
  - stage: GatherCIBuildInfo
    displayName: 'Gather CI build info from all repos'
    dependsOn: CreateBranch
    jobs:
      - deployment: GatherBuildInfo
        displayName: 'Latest CI run and artifact version per repo'
        environment: 'ci-build-approval'
        pool:
          name: 'Default'
        strategy:
          runOnce:
            deploy:
              steps:
                - task: PowerShell@2
                  name: SetArtifactName
                  displayName: 'Set unique artifact name (avoids conflict on rerun)'
                  inputs:
                    targetType: 'inline'
                    script: |
                      $name = "ci-build-info-$(Build.BuildId)-$(System.JobAttempt)"
                      Write-Host "##vso[task.setvariable variable=ArtifactName;isOutput=true]$name"
                      Write-Host "Artifact name: $name"
                - task: PowerShell@2
                  displayName: 'Get latest CI run and artifact version from all repos'
                  env:
                    GITHUB_TOKEN: $(GITHUB_TOKEN)
                  inputs:
                    targetType: 'inline'
                    script: |
                      $ErrorActionPreference = "Stop"
                      # Remove old all-repos-build-info.txt if it exists (e.g. from rerun), then create fresh file
                      $outDir = "$(Build.ArtifactStagingDirectory)/ci-build-info"
                      $outFile = Join-Path $outDir "all-repos-build-info.txt"
                      if (Test-Path $outFile) {
                        Remove-Item $outFile -Force
                        Write-Host "Removed existing all-repos-build-info.txt" -ForegroundColor Yellow
                      }
                      if (Test-Path $outDir) {
                        Get-ChildItem -Path $outDir -File | Remove-Item -Force
                        Write-Host "Cleaned existing files in ci-build-info folder" -ForegroundColor Yellow
                      }

                      $owner = "$(githubOwner)"
                      $branchName = "$(branchName)"
                      $repos = @()
                      if ("$(mario_service_deploy_enabled)" -eq "True") { $repos += "mario_service" }
                      if ("$(contra_app_deploy_enabled)" -eq "True") { $repos += "contra_app" }
                      if ("$(bomber_man_service_deploy_enabled)" -eq "True") { $repos += "bomber_man_service" }
                      if ("$(islander_app_service_deploy_enabled)" -eq "True") { $repos += "islander_app_service" }
                      if ("$(cricket_app_deploy_enabled)" -eq "True") { $repos += "cricket_app" }
                      if ("$(checkmate_checkers_deploy_enabled)" -eq "True") { $repos += "checkmate_checkers" }
                      if ("$(baseball_game_service_deploy_enabled)" -eq "True") { $repos += "baseball_game_service" }
                      if ("$(pokeman_game_deploy_enabled)" -eq "True") { $repos += "pokeman_game" }
                      if ("$(popeye_service_deploy_enabled)" -eq "True") { $repos += "popeye-service" }
                      if ("$(main_terraform_deploy_enabled)" -eq "True") { $repos += "main_terraform" }
                      $baseUrl = "https://api.github.com"
                      $outputLines = @()

                      if (-not $env:GITHUB_TOKEN) {
                        Write-Error "GITHUB_TOKEN is not set. Add a secret pipeline variable (scope: repo + actions read)."
                      }
                      if ($repos.Count -eq 0) {
                        Write-Error "No components enabled. Enable at least one component for the release."
                      }

                      $headers = @{
                        "Authorization" = "token $($env:GITHUB_TOKEN)"
                        "Accept"        = "application/vnd.github.v3+json"
                      }

                      $branchEncoded = [System.Uri]::EscapeDataString($branchName)

                      $buildVersionOverride = @{
                        "mario_service" = "$(mario_service_BuildVersion_override)"
                        "contra_app" = "$(contra_app_BuildVersion_override)"
                        "bomber_man_service" = "$(bomber_man_service_BuildVersion_override)"
                        "islander_app_service" = "$(islander_app_service_BuildVersion_override)"
                        "cricket_app" = "$(cricket_app_BuildVersion_override)"
                        "checkmate_checkers" = "$(checkmate_checkers_BuildVersion_override)"
                        "baseball_game_service" = "$(baseball_game_service_BuildVersion_override)"
                        "pokeman_game" = "$(pokeman_game_BuildVersion_override)"
                        "popeye-service" = "$(popeye_service_BuildVersion_override)"
                        "main_terraform" = "$(main_terraform_BuildVersion_override)"
                      }

                      foreach ($repo in $repos) {
                        try {
                          $override = $buildVersionOverride[$repo]
                          if ($override -and $override.Trim() -ne "") {
                            $outputLines += "$repo - $override"
                            Write-Host "$repo - $override (from input)" -ForegroundColor Green
                            continue
                          }
                          # Get workflow id for CI (ci.yml)
                          $workflows = Invoke-RestMethod -Uri "$baseUrl/repos/$owner/$repo/actions/workflows" -Headers $headers -Method Get
                          $ciWorkflow = $workflows.workflows | Where-Object { $_.path -like "*ci.yml" } | Select-Object -First 1
                          if (-not $ciWorkflow) {
                            $outputLines += "$repo - NA"
                            Write-Host "$repo - NA (no CI workflow)" -ForegroundColor Yellow
                            continue
                          }
                          $workflowId = $ciWorkflow.id
                          # Get latest CI workflow runs for the newly created branch only
                          $runs = Invoke-RestMethod -Uri "$baseUrl/repos/$owner/$repo/actions/workflows/$workflowId/runs?branch=$branchEncoded&per_page=1" -Headers $headers -Method Get
                          if (-not $runs.workflow_runs -or $runs.workflow_runs.Count -eq 0) {
                            $outputLines += "$repo - NA"
                            Write-Host "$repo - NA (no CI run on branch $branchName)" -ForegroundColor Yellow
                            continue
                          }
                          $latestRun = $runs.workflow_runs[0]
                          $runId = $latestRun.id
                          $runStatus = $latestRun.status
                          $runConclusion = $latestRun.conclusion

                          # Get artifacts for latest run on this branch
                          $artifacts = Invoke-RestMethod -Uri "$baseUrl/repos/$owner/$repo/actions/runs/$runId/artifacts" -Headers $headers -Method Get
                          $buildVersion = "NA"
                          if ($artifacts.artifacts -and $artifacts.artifacts.Count -gt 0) {
                            $buildArtifact = $artifacts.artifacts | Where-Object { $_.name -match "^build-" } | Select-Object -First 1
                            if ($buildArtifact) {
                              $buildVersion = $buildArtifact.name -replace "^build-", ""
                            } else {
                              $buildVersion = $artifacts.artifacts[0].name
                            }
                          }

                          $line = "$repo - $buildVersion"
                          $outputLines += $line
                          Write-Host "$line (run: $runId, status: $runStatus, conclusion: $runConclusion)" -ForegroundColor Green
                        } catch {
                          $outputLines += "$repo - NA"
                          Write-Host "Failed for $repo : $_" -ForegroundColor Red
                        }
                      }

                      # Write output file
                      $outDir = "$(Build.ArtifactStagingDirectory)/ci-build-info"
                      New-Item -ItemType Directory -Path $outDir -Force | Out-Null
                      $outFile = Join-Path $outDir "all-repos-build-info.txt"
                      $outputLines | Set-Content -Path $outFile -Encoding UTF8
                      Write-Host "`nOutput file: $outFile" -ForegroundColor Cyan
                      Get-Content $outFile

                - task: PublishPipelineArtifact@1
                  displayName: 'Publish build info file'
                  inputs:
                    targetPath: '$(Build.ArtifactStagingDirectory)/ci-build-info'
                    artifactName: $(SetArtifactName.ArtifactName)
                    publishLocation: 'pipeline'

  - stage: Promote
    displayName: 'Promote'
    dependsOn: GatherCIBuildInfo
    jobs:
      - job: PromoteDummy
        displayName: 'Promote (dummy)'
        pool:
          name: 'Default'
        steps:
          - script: echo "Promote stage - placeholder"'
            displayName: 'Promote'

  # Deploy stages - each requires manual approval before running. Triggers GitHub Deploy workflow only for repos with build artifacts.
  - stage: stage_east_deploy
    displayName: 'Stage East Deploy'
    dependsOn:
      - Promote
      - GatherCIBuildInfo
    jobs:
      - job: WaitForApproval
        displayName: 'Wait for manual approval'
        pool: server
        timeoutInMinutes: 4320
        steps:
          - task: ManualValidation@1
            timeoutInMinutes: 1440
            inputs:
              notifyUsers: ''
              instructions: 'Approve to start Stage East Deploy. Resume when ready.'
              onTimeout: 'reject'
      - job: DeployStageEast
        displayName: 'Deploy to Stage East'
        dependsOn: WaitForApproval
        pool:
          name: 'Default'
        steps:
          - download: none
            displayName: 'Disable default artifact download (we download one artifact explicitly)'
          - task: PowerShell@2
            displayName: 'Resolve latest ci-build-info artifact name'
            env:
              SYSTEM_ACCESSTOKEN: $(System.AccessToken)
            inputs:
              targetType: 'inline'
              script: |
                $buildId = "$(Build.BuildId)"
                $baseUrl = "$(System.CollectionUri)$(System.TeamProject)/_apis/build/builds/$buildId/artifacts?api-version=6.0"
                $artifacts = Invoke-RestMethod -Uri $baseUrl -Headers @{ Authorization = "Bearer $env:SYSTEM_ACCESSTOKEN" } -Method Get
                $ci = $artifacts.value | Where-Object { $_.name -like "ci-build-info-*" } | Sort-Object -Property name -Descending | Select-Object -First 1
                if (-not $ci) { Write-Error "No ci-build-info artifact found for build $buildId" }
                Write-Host "##vso[task.setvariable variable=LatestCiArtifactName]$($ci.name)"
                Write-Host "Using latest artifact: $($ci.name)"
          - task: DownloadPipelineArtifact@2
            displayName: 'Download ci-build-info artifact'
            inputs:
              artifactName: $(LatestCiArtifactName)
              targetPath: '$(Pipeline.Workspace)/ci-build-info'
          - template: deploy-components.yml
            parameters:
              region: 'Stage East'
              owner: $(githubOwner)
              branchName: $(branchName)

  - stage: stage_west_deploy
    displayName: 'Stage West Deploy'
    dependsOn:
      - Promote
      - GatherCIBuildInfo
    jobs:
      - job: WaitForApproval
        displayName: 'Wait for manual approval'
        pool: server
        timeoutInMinutes: 4320
        steps:
          - task: ManualValidation@1
            timeoutInMinutes: 1440
            inputs:
              notifyUsers: ''
              instructions: 'Approve to start Stage West Deploy. Resume when ready.'
              onTimeout: 'reject'
      - job: DeployStageWest
        displayName: 'Deploy to Stage West'
        dependsOn: WaitForApproval
        pool:
          name: 'Default'
        steps:
          - download: none
            displayName: 'Disable default artifact download (we download one artifact explicitly)'
          - task: PowerShell@2
            displayName: 'Resolve latest ci-build-info artifact name'
            env:
              SYSTEM_ACCESSTOKEN: $(System.AccessToken)
            inputs:
              targetType: 'inline'
              script: |
                $buildId = "$(Build.BuildId)"
                $baseUrl = "$(System.CollectionUri)$(System.TeamProject)/_apis/build/builds/$buildId/artifacts?api-version=6.0"
                $artifacts = Invoke-RestMethod -Uri $baseUrl -Headers @{ Authorization = "Bearer $env:SYSTEM_ACCESSTOKEN" } -Method Get
                $ci = $artifacts.value | Where-Object { $_.name -like "ci-build-info-*" } | Sort-Object -Property name -Descending | Select-Object -First 1
                if (-not $ci) { Write-Error "No ci-build-info artifact found for build $buildId" }
                Write-Host "##vso[task.setvariable variable=LatestCiArtifactName]$($ci.name)"
                Write-Host "Using latest artifact: $($ci.name)"
          - task: DownloadPipelineArtifact@2
            displayName: 'Download ci-build-info artifact'
            inputs:
              artifactName: $(LatestCiArtifactName)
              targetPath: '$(Pipeline.Workspace)/ci-build-info'
          - template: deploy-components.yml
            parameters:
              region: 'Stage West'
              owner: $(githubOwner)
              branchName: $(branchName)

  - stage: prod_deploy
    displayName: 'Prod Deploy'
    dependsOn:
      - Promote
      - GatherCIBuildInfo
    jobs:
      - job: WaitForApproval
        displayName: 'Wait for manual approval'
        pool: server
        timeoutInMinutes: 4320
        steps:
          - task: ManualValidation@1
            timeoutInMinutes: 1440
            inputs:
              notifyUsers: ''
              instructions: 'Approve to start Prod Deploy. Resume when ready.'
              onTimeout: 'reject'
      - job: DeployProdEastActive
        displayName: 'Prod Deploy (East active, West passive)'
        dependsOn: WaitForApproval
        condition: eq(variables['prodActiveRegion'], 'EAST-ACTIVE-WEST-PASSIVE')
        pool:
          name: 'Default'
        steps:
          - download: none
            displayName: 'Disable default artifact download (we download one artifact explicitly)'
          # 1. Resolve latest ci-build-info artifact name
          - task: PowerShell@2
            displayName: '1. Resolve latest ci-build-info artifact name'
            env:
              SYSTEM_ACCESSTOKEN: $(System.AccessToken)
            inputs:
              targetType: 'inline'
              script: |
                $buildId = "$(Build.BuildId)"
                $baseUrl = "$(System.CollectionUri)$(System.TeamProject)/_apis/build/builds/$buildId/artifacts?api-version=6.0"
                $artifacts = Invoke-RestMethod -Uri $baseUrl -Headers @{ Authorization = "Bearer $env:SYSTEM_ACCESSTOKEN" } -Method Get
                $ci = $artifacts.value | Where-Object { $_.name -like "ci-build-info-*" } | Sort-Object -Property name -Descending | Select-Object -First 1
                if (-not $ci) { Write-Error "No ci-build-info artifact found for build $buildId" }
                Write-Host "##vso[task.setvariable variable=LatestCiArtifactName]$($ci.name)"
                Write-Host "Using latest artifact: $($ci.name)"
          - script: 'echo "Dummy: Stop db purge pipelines in azure"'
            displayName: '2. Stop db purge pipelines in azure'
          - script: 'echo "Dummy: Disable logic apps in east region"'
            displayName: '3. Disable logic apps in east region'
          - script: 'echo "Dummy: Run db scripts"'
            displayName: '4. Run db scripts'
          - script: 'echo "Dummy: Add Azure secrets and vault secrets in prod-west"'
            displayName: '5. Add Azure secrets and vault secrets in prod-west'
          # 6. Download ci-build-info artifact + deploy-components to Prod West only
          - task: DownloadPipelineArtifact@2
            displayName: '6. Download ci-build-info artifact'
            inputs:
              artifactName: $(LatestCiArtifactName)
              targetPath: '$(Pipeline.Workspace)/ci-build-info'
          - template: deploy-components.yml
            parameters:
              region: 'Prod West'
              owner: $(githubOwner)
              branchName: $(branchName)
              includeParse: true
          - script: 'echo "Dummy: Enable logic apps in prod-west"'
            displayName: '7. Enable logic apps in prod-west'
          - script: 'echo "Dummy: DB failover to prod-west"'
            displayName: '8. DB failover to prod-west'
          - script: 'echo "Dummy: Change traffic to prod-west"'
            displayName: '9. Change traffic to prod-west'
          - script: 'echo "Dummy: Validations on prod-west"'
            displayName: '10. Validations on prod-west'
          - script: 'echo "Dummy: Disable logic apps in west region"'
            displayName: '11. Disable logic apps in west region'
          - script: 'echo "Dummy: Add Azure secrets and vault secrets in prod-east"'
            displayName: '12. Add Azure secrets and vault secrets in prod-east'
          # 13. Deploy components to Prod East (artifact already downloaded at step 6)
          - template: deploy-components.yml
            parameters:
              region: 'Prod East'
              owner: $(githubOwner)
              branchName: $(branchName)
              includeParse: false
          - script: 'echo "Dummy: Enable logic apps in prod-east"'
            displayName: '14. Enable logic apps in prod-east'
          - script: 'echo "Dummy: DB failover to prod-east"'
            displayName: '15. DB failover to prod-east'
          - script: 'echo "Dummy: Change traffic to prod-east"'
            displayName: '16. Change traffic to prod-east'
          - script: 'echo "Dummy: Validations on prod-east"'
            displayName: '17. Validations on prod-east'
      - job: DeployProdWestActive
        displayName: 'Prod Deploy (West active, East passive)'
        dependsOn: WaitForApproval
        condition: eq(variables['prodActiveRegion'], 'WEST-ACTIVE-EAST-PASSIVE')
        pool:
          name: 'Default'
        steps:
          - download: none
            displayName: 'Disable default artifact download (we download one artifact explicitly)'
          # 1. Resolve latest ci-build-info artifact name
          - task: PowerShell@2
            displayName: '1. Resolve latest ci-build-info artifact name'
            env:
              SYSTEM_ACCESSTOKEN: $(System.AccessToken)
            inputs:
              targetType: 'inline'
              script: |
                $buildId = "$(Build.BuildId)"
                $baseUrl = "$(System.CollectionUri)$(System.TeamProject)/_apis/build/builds/$buildId/artifacts?api-version=6.0"
                $artifacts = Invoke-RestMethod -Uri $baseUrl -Headers @{ Authorization = "Bearer $env:SYSTEM_ACCESSTOKEN" } -Method Get
                $ci = $artifacts.value | Where-Object { $_.name -like "ci-build-info-*" } | Sort-Object -Property name -Descending | Select-Object -First 1
                if (-not $ci) { Write-Error "No ci-build-info artifact found for build $buildId" }
                Write-Host "##vso[task.setvariable variable=LatestCiArtifactName]$($ci.name)"
                Write-Host "Using latest artifact: $($ci.name)"
          - script: 'echo "Dummy: Stop db purge pipelines in azure"'
            displayName: '2. Stop db purge pipelines in azure'
          - script: 'echo "Dummy: Disable logic apps in west region"'
            displayName: '3. Disable logic apps in west region'
          - script: 'echo "Dummy: Run db scripts"'
            displayName: '4. Run db scripts'
          - script: 'echo "Dummy: Add Azure secrets and vault secrets in prod-east"'
            displayName: '5. Add Azure secrets and vault secrets in prod-east'
          # 6. Download ci-build-info artifact + deploy-components to Prod East only
          - task: DownloadPipelineArtifact@2
            displayName: '6. Download ci-build-info artifact'
            inputs:
              artifactName: $(LatestCiArtifactName)
              targetPath: '$(Pipeline.Workspace)/ci-build-info'
          - template: deploy-components.yml
            parameters:
              region: 'Prod East'
              owner: $(githubOwner)
              branchName: $(branchName)
              includeParse: true
          - script: 'echo "Dummy: Enable logic apps in prod-east"'
            displayName: '7. Enable logic apps in prod-east'
          - script: 'echo "Dummy: DB failover to prod-east"'
            displayName: '8. DB failover to prod-east'
          - script: 'echo "Dummy: Change traffic to prod-east"'
            displayName: '9. Change traffic to prod-east'
          - script: 'echo "Dummy: Validations on prod-east"'
            displayName: '10. Validations on prod-east'
          - script: 'echo "Dummy: Disable logic apps in east region"'
            displayName: '11. Disable logic apps in east region'
          - script: 'echo "Dummy: Add Azure secrets and vault secrets in prod-west"'
            displayName: '12. Add Azure secrets and vault secrets in prod-west'
          # 13. Deploy components to Prod West (artifact already downloaded at step 6)
          - template: deploy-components.yml
            parameters:
              region: 'Prod West'
              owner: $(githubOwner)
              branchName: $(branchName)
              includeParse: false
          - script: 'echo "Dummy: Enable logic apps in prod-west"'
            displayName: '14. Enable logic apps in prod-west'
          - script: 'echo "Dummy: DB failover to prod-west"'
            displayName: '15. DB failover to prod-west'
          - script: 'echo "Dummy: Change traffic to prod-west"'
            displayName: '16. Change traffic to prod-west'
          - script: 'echo "Dummy: Validations on prod-west"'
            displayName: '17. Validations on prod-west'
