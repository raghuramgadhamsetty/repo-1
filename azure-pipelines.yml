# Pipeline: Create a branch in all 10 GitHub repos (repo-1 through repo-10)
# Run this pipeline and provide the branch name when prompted.

name: ReleasePipeline-$(Build.BuildId)-$(Date:yyyyMMddHHmmss)
appendCommitMessageToRunName: false

trigger: none

parameters:
  - name: branchName
    displayName: 'Branch name to create'
    type: string
  - name: prevReleaseBranch
    displayName: 'Previous release branch (create new branch from this)'
    type: string
    default: main
    values:
      - main
      - master
  - name: githubOwner
    displayName: 'GitHub owner/username'
    type: string
    default: 'raghuramgadhamsetty'
  - name: repo1Enabled
    displayName: 'Component repo-1'
    type: boolean
    default: true
  - name: repo1BuildVersion
    displayName: 'repo-1 Build version (optional)'
    type: string
    default: ' '
  - name: repo2Enabled
    displayName: 'Component repo-2'
    type: boolean
    default: true
  - name: repo2BuildVersion
    displayName: 'repo-2 Build version (optional)'
    type: string
    default: ' '
  - name: repo3Enabled
    displayName: 'Component repo-3'
    type: boolean
    default: true
  - name: repo3BuildVersion
    displayName: 'repo-3 Build version (optional)'
    type: string
    default: ' '
  - name: repo4Enabled
    displayName: 'Component repo-4'
    type: boolean
    default: true
  - name: repo4BuildVersion
    displayName: 'repo-4 Build version (optional)'
    type: string
    default: ' '
  - name: repo5Enabled
    displayName: 'Component repo-5'
    type: boolean
    default: true
  - name: repo5BuildVersion
    displayName: 'repo-5 Build version (optional)'
    type: string
    default: ' '
  - name: repo6Enabled
    displayName: 'Component repo-6'
    type: boolean
    default: true
  - name: repo6BuildVersion
    displayName: 'repo-6 Build version (optional)'
    type: string
    default: ' '
  - name: repo7Enabled
    displayName: 'Component repo-7'
    type: boolean
    default: true
  - name: repo7BuildVersion
    displayName: 'repo-7 Build version (optional)'
    type: string
    default: ' '
  - name: repo8Enabled
    displayName: 'Component repo-8'
    type: boolean
    default: true
  - name: repo8BuildVersion
    displayName: 'repo-8 Build version (optional)'
    type: string
    default: ' '
  - name: repo9Enabled
    displayName: 'Component repo-9'
    type: boolean
    default: true
  - name: repo9BuildVersion
    displayName: 'repo-9 Build version (optional)'
    type: string
    default: ' '
  - name: repo10Enabled
    displayName: 'Component repo-10'
    type: boolean
    default: true
  - name: repo10BuildVersion
    displayName: 'repo-10 Build version (optional)'
    type: string
    default: ' '
  - name: prodActiveRegion
    displayName: 'Prod active region'
    type: string
    default: 'EAST-ACTIVE-WEST-PASSIVE'
    values:
      - EAST-ACTIVE-WEST-PASSIVE
      - WEST-ACTIVE-EAST-PASSIVE

variables:
  - name: repoList
    value: 'repo-1,repo-2,repo-3,repo-4,repo-5,repo-6,repo-7,repo-8,repo-9,repo-10'

stages:
  - stage: Validate
    displayName: 'Validate inputs'
    jobs:
      - job: ValidateInputs
        displayName: 'Check parameters'
        pool:
          name: 'Default'
        steps:
          - script: |
              echo "Branch name: ${{ parameters.branchName }}"
              echo "Previous release branch: ${{ parameters.prevReleaseBranch }}"
              echo "GitHub owner: ${{ parameters.githubOwner }}"
              echo "Components enabled: repo-1=${{ parameters.repo1Enabled }} repo-2=${{ parameters.repo2Enabled }} repo-3=${{ parameters.repo3Enabled }} repo-4=${{ parameters.repo4Enabled }} repo-5=${{ parameters.repo5Enabled }} repo-6=${{ parameters.repo6Enabled }} repo-7=${{ parameters.repo7Enabled }} repo-8=${{ parameters.repo8Enabled }} repo-9=${{ parameters.repo9Enabled }} repo-10=${{ parameters.repo10Enabled }}"
            displayName: 'Show parameters'

  - stage: CreateBranch
    displayName: 'Create branch in all repos'
    dependsOn: Validate
    jobs:
      - job: CreateBranchInAllRepos
        displayName: 'Create branch across repo-1 to repo-10'
        pool:
          name: 'Default'
        steps:
          - task: PowerShell@2
            displayName: 'Create branch in all 10 repos'
            env:
              GITHUB_TOKEN: $(GITHUB_TOKEN)
            inputs:
              targetType: 'inline'
              script: |
                $ErrorActionPreference = "Stop"
                $branchName = "${{ parameters.branchName }}"
                $prevReleaseBranch = "${{ parameters.prevReleaseBranch }}"
                $owner = "${{ parameters.githubOwner }}"
                $repos = @()
                if ("${{ parameters.repo1Enabled }}" -eq "True") { $repos += "repo-1" }
                if ("${{ parameters.repo2Enabled }}" -eq "True") { $repos += "repo-2" }
                if ("${{ parameters.repo3Enabled }}" -eq "True") { $repos += "repo-3" }
                if ("${{ parameters.repo4Enabled }}" -eq "True") { $repos += "repo-4" }
                if ("${{ parameters.repo5Enabled }}" -eq "True") { $repos += "repo-5" }
                if ("${{ parameters.repo6Enabled }}" -eq "True") { $repos += "repo-6" }
                if ("${{ parameters.repo7Enabled }}" -eq "True") { $repos += "repo-7" }
                if ("${{ parameters.repo8Enabled }}" -eq "True") { $repos += "repo-8" }
                if ("${{ parameters.repo9Enabled }}" -eq "True") { $repos += "repo-9" }
                if ("${{ parameters.repo10Enabled }}" -eq "True") { $repos += "repo-10" }
                if ($repos.Count -eq 0) { Write-Error "At least one component must be enabled." }
                $baseUrl = "https://api.github.com"

                if (-not $env:GITHUB_TOKEN) {
                  Write-Error "GITHUB_TOKEN is not set. Add a secret pipeline variable named GITHUB_TOKEN with your GitHub PAT (scope: repo)."
                }
                if (-not $branchName) {
                  Write-Error "Branch name is required. Run the pipeline with the branchName parameter."
                }
                if (-not $prevReleaseBranch) {
                  Write-Error "Previous release branch is required. Run the pipeline with the prevReleaseBranch parameter."
                }

                $headers = @{
                  "Authorization" = "token $($env:GITHUB_TOKEN)"
                  "Accept"        = "application/vnd.github.v3+json"
                }

                foreach ($repo in $repos) {
                  try {
                    # Get previous release branch SHA - fail if branch does not exist
                    $ref = "heads/" + [System.Uri]::EscapeDataString($prevReleaseBranch)
                    $refInfo = Invoke-RestMethod -Uri "$baseUrl/repos/$owner/$repo/git/ref/$ref" -Headers $headers -Method Get
                    $sha = $refInfo.object.sha
                  } catch {
                    if ($_.Exception.Response.StatusCode -eq 404) {
                      Write-Error "Previous branch '$prevReleaseBranch' does not exist in $repo. Pipeline failed."
                    } else {
                      throw $_
                    }
                  }

                  try {
                    # Create new branch from previous release
                    $body = @{ ref = "refs/heads/$branchName"; sha = $sha } | ConvertTo-Json
                    Invoke-RestMethod -Uri "$baseUrl/repos/$owner/$repo/git/refs" -Headers $headers -Method Post -Body $body -ContentType "application/json"
                    Write-Host "Created branch '$branchName' in $repo" -ForegroundColor Green
                  } catch {
                    if ($_.Exception.Response.StatusCode -eq 422) {
                      Write-Host "Branch '$branchName' already exists in $repo (skipped)" -ForegroundColor Yellow
                    } else {
                      Write-Host "Failed for $repo : $_" -ForegroundColor Red
                    }
                  }
                }
                Write-Host "`nDone. Branch '$branchName' is now in all 10 repos." -ForegroundColor Cyan

  # Stage 3: Requires approval before generating artifact.
  # Create environment 'ci-build-approval' in DevOps (Pipelines > Environments) and add Approvals.
  - stage: GatherCIBuildInfo
    displayName: 'Gather CI build info from all repos'
    dependsOn: CreateBranch
    jobs:
      - deployment: GatherBuildInfo
        displayName: 'Latest CI run and artifact version per repo'
        environment: 'ci-build-approval'
        pool:
          name: 'Default'
        strategy:
          runOnce:
            deploy:
              steps:
                - task: PowerShell@2
                  displayName: 'Get latest CI run and artifact version from all repos'
                  env:
                    GITHUB_TOKEN: $(GITHUB_TOKEN)
                  inputs:
                    targetType: 'inline'
                    script: |
                      $ErrorActionPreference = "Stop"
                      $owner = "${{ parameters.githubOwner }}"
                      $branchName = "${{ parameters.branchName }}"
                      $repos = @()
                      if ("${{ parameters.repo1Enabled }}" -eq "True") { $repos += "repo-1" }
                      if ("${{ parameters.repo2Enabled }}" -eq "True") { $repos += "repo-2" }
                      if ("${{ parameters.repo3Enabled }}" -eq "True") { $repos += "repo-3" }
                      if ("${{ parameters.repo4Enabled }}" -eq "True") { $repos += "repo-4" }
                      if ("${{ parameters.repo5Enabled }}" -eq "True") { $repos += "repo-5" }
                      if ("${{ parameters.repo6Enabled }}" -eq "True") { $repos += "repo-6" }
                      if ("${{ parameters.repo7Enabled }}" -eq "True") { $repos += "repo-7" }
                      if ("${{ parameters.repo8Enabled }}" -eq "True") { $repos += "repo-8" }
                      if ("${{ parameters.repo9Enabled }}" -eq "True") { $repos += "repo-9" }
                      if ("${{ parameters.repo10Enabled }}" -eq "True") { $repos += "repo-10" }
                      $baseUrl = "https://api.github.com"
                      $outputLines = @()

                      if (-not $env:GITHUB_TOKEN) {
                        Write-Error "GITHUB_TOKEN is not set. Add a secret pipeline variable (scope: repo + actions read)."
                      }
                      if ($repos.Count -eq 0) {
                        Write-Error "No components enabled. Enable at least one component for the release."
                      }

                      $headers = @{
                        "Authorization" = "token $($env:GITHUB_TOKEN)"
                        "Accept"        = "application/vnd.github.v3+json"
                      }

                      $branchEncoded = [System.Uri]::EscapeDataString($branchName)

                      $buildVersionOverride = @{
                        "repo-1" = "${{ parameters.repo1BuildVersion }}"
                        "repo-2" = "${{ parameters.repo2BuildVersion }}"
                        "repo-3" = "${{ parameters.repo3BuildVersion }}"
                        "repo-4" = "${{ parameters.repo4BuildVersion }}"
                        "repo-5" = "${{ parameters.repo5BuildVersion }}"
                        "repo-6" = "${{ parameters.repo6BuildVersion }}"
                        "repo-7" = "${{ parameters.repo7BuildVersion }}"
                        "repo-8" = "${{ parameters.repo8BuildVersion }}"
                        "repo-9" = "${{ parameters.repo9BuildVersion }}"
                        "repo-10" = "${{ parameters.repo10BuildVersion }}"
                      }

                      foreach ($repo in $repos) {
                        try {
                          $override = $buildVersionOverride[$repo]
                          if ($override -and $override.Trim() -ne "") {
                            $outputLines += "$repo - $override"
                            Write-Host "$repo - $override (from input)" -ForegroundColor Green
                            continue
                          }
                          # Get workflow id for CI (ci.yml)
                          $workflows = Invoke-RestMethod -Uri "$baseUrl/repos/$owner/$repo/actions/workflows" -Headers $headers -Method Get
                          $ciWorkflow = $workflows.workflows | Where-Object { $_.path -like "*ci.yml" } | Select-Object -First 1
                          if (-not $ciWorkflow) {
                            $outputLines += "$repo - NA"
                            Write-Host "$repo - NA (no CI workflow)" -ForegroundColor Yellow
                            continue
                          }
                          $workflowId = $ciWorkflow.id
                          # Get latest CI workflow runs for the newly created branch only
                          $runs = Invoke-RestMethod -Uri "$baseUrl/repos/$owner/$repo/actions/workflows/$workflowId/runs?branch=$branchEncoded&per_page=1" -Headers $headers -Method Get
                          if (-not $runs.workflow_runs -or $runs.workflow_runs.Count -eq 0) {
                            $outputLines += "$repo - NA"
                            Write-Host "$repo - NA (no CI run on branch $branchName)" -ForegroundColor Yellow
                            continue
                          }
                          $latestRun = $runs.workflow_runs[0]
                          $runId = $latestRun.id
                          $runStatus = $latestRun.status
                          $runConclusion = $latestRun.conclusion

                          # Get artifacts for latest run on this branch
                          $artifacts = Invoke-RestMethod -Uri "$baseUrl/repos/$owner/$repo/actions/runs/$runId/artifacts" -Headers $headers -Method Get
                          $buildVersion = "NA"
                          if ($artifacts.artifacts -and $artifacts.artifacts.Count -gt 0) {
                            $buildArtifact = $artifacts.artifacts | Where-Object { $_.name -match "^build-" } | Select-Object -First 1
                            if ($buildArtifact) {
                              $buildVersion = $buildArtifact.name -replace "^build-", ""
                            } else {
                              $buildVersion = $artifacts.artifacts[0].name
                            }
                          }

                          $line = "$repo - $buildVersion"
                          $outputLines += $line
                          Write-Host "$line (run: $runId, status: $runStatus, conclusion: $runConclusion)" -ForegroundColor Green
                        } catch {
                          $outputLines += "$repo - NA"
                          Write-Host "Failed for $repo : $_" -ForegroundColor Red
                        }
                      }

                      # Write output file
                      $outDir = "$(Build.ArtifactStagingDirectory)/ci-build-info"
                      New-Item -ItemType Directory -Path $outDir -Force | Out-Null
                      $outFile = Join-Path $outDir "all-repos-build-info.txt"
                      $outputLines | Set-Content -Path $outFile -Encoding UTF8
                      Write-Host "`nOutput file: $outFile" -ForegroundColor Cyan
                      Get-Content $outFile

                - task: PublishPipelineArtifact@1
                  displayName: 'Publish build info file'
                  inputs:
                    targetPath: '$(Build.ArtifactStagingDirectory)/ci-build-info'
                    artifactName: 'ci-build-info'
                    publishLocation: 'pipeline'

  - stage: Promote
    displayName: 'Promote'
    dependsOn: GatherCIBuildInfo
    jobs:
      - job: PromoteDummy
        displayName: 'Promote (dummy)'
        pool:
          name: 'Default'
        steps:
          - script: echo "Promote stage - placeholder"
            displayName: 'Promote'

  # Deploy stages - each has its own approval. Triggers GitHub Deploy workflow only for repos with build artifacts.
  - stage: stage_east_deploy
    displayName: 'Stage East Deploy'
    dependsOn: Promote
    jobs:
      - deployment: DeployStageEast
        displayName: 'Deploy to Stage East'
        environment: 'deploy-stage-east'
        pool:
          name: 'Default'
        strategy:
          runOnce:
            deploy:
              steps:
                - task: DownloadPipelineArtifact@2
                  displayName: 'Download ci-build-info artifact'
                  inputs:
                    artifactName: 'ci-build-info'
                    targetPath: '$(Pipeline.Workspace)/ci-build-info'
                - task: PowerShell@2
                  displayName: 'Trigger deploy for repos with artifacts (Stage East)'
                  env:
                    GITHUB_TOKEN: $(GITHUB_TOKEN)
                  inputs:
                    targetType: 'inline'
                    script: |
                      $ErrorActionPreference = "Stop"
                      $owner = "${{ parameters.githubOwner }}"
                      $branchName = "${{ parameters.branchName }}"
                      $baseUrl = "https://api.github.com"
                      $infoFile = "$(Pipeline.Workspace)/ci-build-info/all-repos-build-info.txt"
                      $region = "Stage East"

                      if (-not $env:GITHUB_TOKEN) { Write-Error "GITHUB_TOKEN not set" }
                      if (-not (Test-Path $infoFile)) { Write-Error "Build info file not found" }

                      $headers = @{
                        "Authorization" = "token $($env:GITHUB_TOKEN)"
                        "Accept"        = "application/vnd.github.v3+json"
                      }

                      $triggered = 0
                      $skipped = 0
                      $branchEncoded = [System.Uri]::EscapeDataString($branchName)
                      foreach ($line in Get-Content $infoFile) {
                        $parts = $line -split ' - ', 2
                        if ($parts.Count -lt 2) { continue }
                        $repo = $parts[0].Trim()
                        $version = $parts[1].Trim()
                        if ($version -eq "NA") {
                          Write-Host "Skipping $repo - no artifact (NA)" -ForegroundColor Yellow
                          $skipped++
                          continue
                        }
                        try {
                          $body = @{ ref = $branchName } | ConvertTo-Json
                          Invoke-RestMethod -Uri "$baseUrl/repos/$owner/$repo/actions/workflows/deploy.yml/dispatches" -Headers $headers -Method Post -Body $body -ContentType "application/json"
                          Write-Host "Triggered deploy in $repo ($version) - ${region}. Waiting for completion..." -ForegroundColor Green
                          Start-Sleep -Seconds 5
                          $runs = Invoke-RestMethod -Uri "$baseUrl/repos/$owner/$repo/actions/workflows/deploy.yml/runs?branch=$branchEncoded&per_page=5" -Headers $headers -Method Get
                          $runId = $runs.workflow_runs[0].id
                          $run = $null
                          do {
                            Start-Sleep -Seconds 10
                            $run = Invoke-RestMethod -Uri "$baseUrl/repos/$owner/$repo/actions/runs/$runId" -Headers $headers -Method Get
                            Write-Host "  $repo deploy status: $($run.status)" -ForegroundColor Gray
                          } while ($run.status -ne "completed")
                          if ($run.conclusion -ne "success") {
                            Write-Error "Deploy failed in $repo - conclusion: $($run.conclusion)"
                          }
                          $logsUrl = "$baseUrl/repos/$owner/$repo/actions/runs/$runId/logs"
                          $zipPath = "$(Pipeline.Workspace)/deploy-logs-$repo.zip"
                          Invoke-WebRequest -Uri $logsUrl -Headers @{ Authorization = "token $($env:GITHUB_TOKEN)" } -OutFile $zipPath -UseBasicParsing
                          $extractPath = "$(Pipeline.Workspace)/deploy-logs-$repo"
                          Expand-Archive -Path $zipPath -DestinationPath $extractPath -Force
                          $logFile = Get-ChildItem -Path $extractPath -Recurse -File | Where-Object { $_.Extension -eq ".txt" } | Sort-Object Length -Descending | Select-Object -First 1
                          if ($logFile) {
                            $lastLines = Get-Content $logFile.FullName -Tail 3
                            Write-Host "  Last 3 lines of deploy log for $repo :" -ForegroundColor Cyan
                            $lastLines | ForEach-Object { Write-Host "    $_" }
                          }
                          Remove-Item $zipPath -Force -ErrorAction SilentlyContinue
                          Remove-Item $extractPath -Recurse -Force -ErrorAction SilentlyContinue
                          $triggered++
                        } catch {
                          Write-Error "Failed for $repo : $_"
                        }
                      }
                      Write-Host "`n${region}: Triggered $triggered repos, skipped $skipped (NA)" -ForegroundColor Cyan

  - stage: stage_west_deploy
    displayName: 'Stage West Deploy'
    dependsOn: Promote
    jobs:
      - deployment: DeployStageWest
        displayName: 'Deploy to Stage West'
        environment: 'deploy-stage-west'
        pool:
          name: 'Default'
        strategy:
          runOnce:
            deploy:
              steps:
                - task: DownloadPipelineArtifact@2
                  displayName: 'Download ci-build-info artifact'
                  inputs:
                    artifactName: 'ci-build-info'
                    targetPath: '$(Pipeline.Workspace)/ci-build-info'
                - task: PowerShell@2
                  displayName: 'Trigger deploy for repos with artifacts (Stage West)'
                  env:
                    GITHUB_TOKEN: $(GITHUB_TOKEN)
                  inputs:
                    targetType: 'inline'
                    script: |
                      $ErrorActionPreference = "Stop"
                      $owner = "${{ parameters.githubOwner }}"
                      $branchName = "${{ parameters.branchName }}"
                      $baseUrl = "https://api.github.com"
                      $infoFile = "$(Pipeline.Workspace)/ci-build-info/all-repos-build-info.txt"
                      $region = "Stage West"

                      if (-not $env:GITHUB_TOKEN) { Write-Error "GITHUB_TOKEN not set" }
                      if (-not (Test-Path $infoFile)) { Write-Error "Build info file not found" }

                      $headers = @{
                        "Authorization" = "token $($env:GITHUB_TOKEN)"
                        "Accept"        = "application/vnd.github.v3+json"
                      }

                      $triggered = 0
                      $skipped = 0
                      $branchEncoded = [System.Uri]::EscapeDataString($branchName)
                      foreach ($line in Get-Content $infoFile) {
                        $parts = $line -split ' - ', 2
                        if ($parts.Count -lt 2) { continue }
                        $repo = $parts[0].Trim()
                        $version = $parts[1].Trim()
                        if ($version -eq "NA") {
                          Write-Host "Skipping $repo - no artifact (NA)" -ForegroundColor Yellow
                          $skipped++
                          continue
                        }
                        try {
                          $body = @{ ref = $branchName } | ConvertTo-Json
                          Invoke-RestMethod -Uri "$baseUrl/repos/$owner/$repo/actions/workflows/deploy.yml/dispatches" -Headers $headers -Method Post -Body $body -ContentType "application/json"
                          Write-Host "Triggered deploy in $repo ($version) - ${region}. Waiting for completion..." -ForegroundColor Green
                          Start-Sleep -Seconds 5
                          $runs = Invoke-RestMethod -Uri "$baseUrl/repos/$owner/$repo/actions/workflows/deploy.yml/runs?branch=$branchEncoded&per_page=5" -Headers $headers -Method Get
                          $runId = $runs.workflow_runs[0].id
                          $run = $null
                          do {
                            Start-Sleep -Seconds 10
                            $run = Invoke-RestMethod -Uri "$baseUrl/repos/$owner/$repo/actions/runs/$runId" -Headers $headers -Method Get
                            Write-Host "  $repo deploy status: $($run.status)" -ForegroundColor Gray
                          } while ($run.status -ne "completed")
                          if ($run.conclusion -ne "success") {
                            Write-Error "Deploy failed in $repo - conclusion: $($run.conclusion)"
                          }
                          $logsUrl = "$baseUrl/repos/$owner/$repo/actions/runs/$runId/logs"
                          $zipPath = "$(Pipeline.Workspace)/deploy-logs-$repo.zip"
                          Invoke-WebRequest -Uri $logsUrl -Headers @{ Authorization = "token $($env:GITHUB_TOKEN)" } -OutFile $zipPath -UseBasicParsing
                          $extractPath = "$(Pipeline.Workspace)/deploy-logs-$repo"
                          Expand-Archive -Path $zipPath -DestinationPath $extractPath -Force
                          $logFile = Get-ChildItem -Path $extractPath -Recurse -File | Where-Object { $_.Extension -eq ".txt" } | Sort-Object Length -Descending | Select-Object -First 1
                          if ($logFile) {
                            $lastLines = Get-Content $logFile.FullName -Tail 3
                            Write-Host "  Last 3 lines of deploy log for $repo :" -ForegroundColor Cyan
                            $lastLines | ForEach-Object { Write-Host "    $_" }
                          }
                          Remove-Item $zipPath -Force -ErrorAction SilentlyContinue
                          Remove-Item $extractPath -Recurse -Force -ErrorAction SilentlyContinue
                          $triggered++
                        } catch {
                          Write-Error "Failed for $repo : $_"
                        }
                      }
                      Write-Host "`n${region}: Triggered $triggered repos, skipped $skipped (NA)" -ForegroundColor Cyan

  - stage: prod_deploy
    displayName: 'Prod Deploy'
    dependsOn:
      - stage_east_deploy
      - stage_west_deploy
    jobs:
      - deployment: DeployProd
        displayName: 'Prod Deploy (passive then active)'
        environment: 'deploy-prod'
        pool:
          name: 'Default'
        strategy:
          runOnce:
            deploy:
              steps:
                - task: DownloadPipelineArtifact@2
                  displayName: 'Download ci-build-info artifact'
                  inputs:
                    artifactName: 'ci-build-info'
                    targetPath: '$(Pipeline.Workspace)/ci-build-info'
                - task: PowerShell@2
                  displayName: 'Prod - Deploy to passive region first'
                  env:
                    GITHUB_TOKEN: $(GITHUB_TOKEN)
                  inputs:
                    targetType: 'inline'
                    script: |
                      $ErrorActionPreference = "Stop"
                      $prodActiveRegion = "${{ parameters.prodActiveRegion }}"
                      if ($prodActiveRegion -eq "EAST-ACTIVE-WEST-PASSIVE") { $region = "Prod Passive (West)" } else { $region = "Prod Passive (East)" }
                      $owner = "${{ parameters.githubOwner }}"
                      $branchName = "${{ parameters.branchName }}"
                      $baseUrl = "https://api.github.com"
                      $infoFile = "$(Pipeline.Workspace)/ci-build-info/all-repos-build-info.txt"
                      if (-not $env:GITHUB_TOKEN) { Write-Error "GITHUB_TOKEN not set" }
                      if (-not (Test-Path $infoFile)) { Write-Error "Build info file not found" }
                      $headers = @{ "Authorization" = "token $($env:GITHUB_TOKEN)"; "Accept" = "application/vnd.github.v3+json" }
                      $triggered = 0; $skipped = 0
                      $branchEncoded = [System.Uri]::EscapeDataString($branchName)
                      foreach ($line in Get-Content $infoFile) {
                        $parts = $line -split ' - ', 2
                        if ($parts.Count -lt 2) { continue }
                        $repo = $parts[0].Trim(); $version = $parts[1].Trim()
                        if ($version -eq "NA") { Write-Host "Skipping $repo - no artifact (NA)" -ForegroundColor Yellow; $skipped++; continue }
                        try {
                          $body = @{ ref = $branchName } | ConvertTo-Json
                          Invoke-RestMethod -Uri "$baseUrl/repos/$owner/$repo/actions/workflows/deploy.yml/dispatches" -Headers $headers -Method Post -Body $body -ContentType "application/json"
                          Write-Host "Triggered deploy in $repo ($version) - ${region}. Waiting for completion..." -ForegroundColor Green
                          Start-Sleep -Seconds 5
                          $runs = Invoke-RestMethod -Uri "$baseUrl/repos/$owner/$repo/actions/workflows/deploy.yml/runs?branch=$branchEncoded&per_page=5" -Headers $headers -Method Get
                          $runId = $runs.workflow_runs[0].id
                          do { Start-Sleep -Seconds 10; $run = Invoke-RestMethod -Uri "$baseUrl/repos/$owner/$repo/actions/runs/$runId" -Headers $headers -Method Get; Write-Host "  $repo deploy status: $($run.status)" -ForegroundColor Gray } while ($run.status -ne "completed")
                          if ($run.conclusion -ne "success") { Write-Error "Deploy failed in $repo - conclusion: $($run.conclusion)" }
                          $zipPath = "$(Pipeline.Workspace)/deploy-logs-$repo.zip"
                          Invoke-WebRequest -Uri "$baseUrl/repos/$owner/$repo/actions/runs/$runId/logs" -Headers @{ Authorization = "token $($env:GITHUB_TOKEN)" } -OutFile $zipPath -UseBasicParsing
                          $extractPath = "$(Pipeline.Workspace)/deploy-logs-$repo"; Expand-Archive -Path $zipPath -DestinationPath $extractPath -Force
                          $logFile = Get-ChildItem -Path $extractPath -Recurse -File | Where-Object { $_.Extension -eq ".txt" } | Sort-Object Length -Descending | Select-Object -First 1
                          if ($logFile) { Get-Content $logFile.FullName -Tail 3 | ForEach-Object { Write-Host "    $_" } }
                          Remove-Item $zipPath -Force -ErrorAction SilentlyContinue; Remove-Item $extractPath -Recurse -Force -ErrorAction SilentlyContinue
                          $triggered++
                        } catch { Write-Error "Failed for $repo : $_" }
                      }
                      Write-Host "`n${region}: Triggered $triggered repos, skipped $skipped (NA)" -ForegroundColor Cyan
                - task: PowerShell@2
                  displayName: 'Prod - Deploy to active region'
                  env:
                    GITHUB_TOKEN: $(GITHUB_TOKEN)
                  inputs:
                    targetType: 'inline'
                    script: |
                      $ErrorActionPreference = "Stop"
                      $prodActiveRegion = "${{ parameters.prodActiveRegion }}"
                      if ($prodActiveRegion -eq "EAST-ACTIVE-WEST-PASSIVE") { $region = "Prod Active (East)" } else { $region = "Prod Active (West)" }
                      $owner = "${{ parameters.githubOwner }}"
                      $branchName = "${{ parameters.branchName }}"
                      $baseUrl = "https://api.github.com"
                      $infoFile = "$(Pipeline.Workspace)/ci-build-info/all-repos-build-info.txt"
                      if (-not $env:GITHUB_TOKEN) { Write-Error "GITHUB_TOKEN not set" }
                      if (-not (Test-Path $infoFile)) { Write-Error "Build info file not found" }
                      $headers = @{ "Authorization" = "token $($env:GITHUB_TOKEN)"; "Accept" = "application/vnd.github.v3+json" }
                      $triggered = 0; $skipped = 0
                      $branchEncoded = [System.Uri]::EscapeDataString($branchName)
                      foreach ($line in Get-Content $infoFile) {
                        $parts = $line -split ' - ', 2
                        if ($parts.Count -lt 2) { continue }
                        $repo = $parts[0].Trim(); $version = $parts[1].Trim()
                        if ($version -eq "NA") { Write-Host "Skipping $repo - no artifact (NA)" -ForegroundColor Yellow; $skipped++; continue }
                        try {
                          $body = @{ ref = $branchName } | ConvertTo-Json
                          Invoke-RestMethod -Uri "$baseUrl/repos/$owner/$repo/actions/workflows/deploy.yml/dispatches" -Headers $headers -Method Post -Body $body -ContentType "application/json"
                          Write-Host "Triggered deploy in $repo ($version) - ${region}. Waiting for completion..." -ForegroundColor Green
                          Start-Sleep -Seconds 5
                          $runs = Invoke-RestMethod -Uri "$baseUrl/repos/$owner/$repo/actions/workflows/deploy.yml/runs?branch=$branchEncoded&per_page=5" -Headers $headers -Method Get
                          $runId = $runs.workflow_runs[0].id
                          do { Start-Sleep -Seconds 10; $run = Invoke-RestMethod -Uri "$baseUrl/repos/$owner/$repo/actions/runs/$runId" -Headers $headers -Method Get; Write-Host "  $repo deploy status: $($run.status)" -ForegroundColor Gray } while ($run.status -ne "completed")
                          if ($run.conclusion -ne "success") { Write-Error "Deploy failed in $repo - conclusion: $($run.conclusion)" }
                          $zipPath = "$(Pipeline.Workspace)/deploy-logs-$repo.zip"
                          Invoke-WebRequest -Uri "$baseUrl/repos/$owner/$repo/actions/runs/$runId/logs" -Headers @{ Authorization = "token $($env:GITHUB_TOKEN)" } -OutFile $zipPath -UseBasicParsing
                          $extractPath = "$(Pipeline.Workspace)/deploy-logs-$repo"; Expand-Archive -Path $zipPath -DestinationPath $extractPath -Force
                          $logFile = Get-ChildItem -Path $extractPath -Recurse -File | Where-Object { $_.Extension -eq ".txt" } | Sort-Object Length -Descending | Select-Object -First 1
                          if ($logFile) { Get-Content $logFile.FullName -Tail 3 | ForEach-Object { Write-Host "    $_" } }
                          Remove-Item $zipPath -Force -ErrorAction SilentlyContinue; Remove-Item $extractPath -Recurse -Force -ErrorAction SilentlyContinue
                          $triggered++
                        } catch { Write-Error "Failed for $repo : $_" }
                      }
                      Write-Host "`n${region}: Triggered $triggered repos, skipped $skipped (NA)" -ForegroundColor Cyan
